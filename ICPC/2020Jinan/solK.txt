这题没法二分答案，放弃

考虑单纯询问 ai 的第 k 大怎么做，显然建 01-trie 可过

先从这个方向思考：所有的区间 1 - MAXR 中，每一个数做 S，生成的 bi 再求第 k 大

相当于使用基于 S 的某些 01-子树反转，进入 01-trie ，再求第 k 大

那么反向考虑

我们先预处理每个 ai 对应哪些 S

考虑这个 01-trie 上往下走的过程，实际上会发现在经历若干次交换之后

剩余一条链到底的时候，是可以自由交换的

所以这些 S 分布在一个连续的区间上

也就是对于 [1,MAXR] 做一个连续子序列切分，每个子序列都会对于唯一一个 ai

然后就可以预处理这点

之后每个 [L,R] 询问，都覆盖了左右两段不完整区间和中间一些完整区间。

这样中间用线段树取 min, 左右暴力

对于取min，由于最后是取 bi 的 min，而预处理的连续区间中每一个 S 产生的所有 bi 都不相同

但是都是基于这个区间对应的 ai 产生（也就是 ai 不变，S 从 Li 变到 Ri）

用一个基于二进制的贪心，处理 Li-Ri 里和 ai 异或能产生的最大的 bi 即可。

两端的暴力也用这种方法处理，每个询问处理两次

中间的预处理好，再上线段树